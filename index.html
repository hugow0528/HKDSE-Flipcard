<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Wabi-Sabi Flashcards | HKDSE Study Tool</title>
  <script type="importmap">
    {
      "imports": {
        "@google/genai": "https://esm.sh/@google/genai@^0.12.0"
      }
    }
  </script>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #f8f9fa;
      --surface-color: #ffffff;
      --text-primary: #212529;
      --text-secondary: #6c757d;
      --accent-color: #4a6a8a;
      --accent-hover: #3a556d;
      --border-color: #dee2e6;
      --error-color: #dc3545;
      --correct-color: #198754;
      --shadow-light: rgba(0, 0, 0, 0.05);
      --shadow-medium: rgba(0, 0, 0, 0.1);
      --font-family-en: 'Inter', sans-serif;
      --font-family-zh: 'Noto Sans TC', sans-serif;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      scroll-behavior: smooth;
    }

    body {
      font-family: var(--font-family-en), var(--font-family-zh);
      background-color: var(--bg-color);
      color: var(--text-primary);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      align-items: center;
      min-height: 100vh;
      padding: 2rem 1rem;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    .container {
      background-color: var(--surface-color);
      padding: 2.5rem;
      border-radius: 16px;
      box-shadow: 0 8px 32px var(--shadow-light);
      width: 100%;
      max-width: 900px;
      text-align: center;
      transition: opacity 0.4s ease, transform 0.4s ease;
      margin-bottom: 2rem;
    }
    
    .container.hidden {
        opacity: 0;
        transform: scale(0.98);
        pointer-events: none;
    }

    .app-header {
      border-bottom: 1px solid var(--border-color);
      padding-bottom: 1.5rem;
      margin-bottom: 2rem;
      width: 100%;
    }
    
    .header-main {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.75rem;
      gap: 1rem;
      flex-wrap: wrap;
    }

    .header-actions {
        display: flex;
        gap: 0.5rem;
        align-items: center;
    }
    
    .language-switcher {
        display: flex;
        gap: 0.5rem;
        border: 1px solid var(--border-color);
        padding: 4px;
        border-radius: 8px;
    }
    
    .lang-button {
        background: none;
        border: none;
        color: var(--text-secondary);
        cursor: pointer;
        padding: 0.25rem 0.5rem;
        border-radius: 6px;
        font-size: 0.9rem;
        font-weight: 500;
        transition: background-color 0.2s, color 0.2s;
    }
    
    .lang-button.active {
        background-color: var(--accent-color);
        color: white;
    }
    
    .lang-button:not(.active):hover {
        background-color: #e9ecef;
        color: var(--text-primary);
    }

    h1 {
      color: var(--text-primary);
      margin: 0;
      font-weight: 700;
      font-size: 2rem;
      text-align: left;
    }
    
    .app-header p {
      text-align: left;
      margin: 0;
      color: var(--text-secondary);
      line-height: 1.6;
    }

    #apiKeyModalInput, textarea, .text-input {
      width: 100%;
      padding: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      font-size: 1rem;
      background-color: var(--bg-color);
      color: var(--text-primary);
      transition: border-color 0.3s ease, box-shadow 0.3s ease;
      font-family: inherit;
    }
    
    #apiKeyModalInput:focus, textarea:focus, .text-input:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(74, 106, 138, 0.2);
    }
    
    textarea {
      min-height: 120px;
      resize: vertical;
      margin-bottom: 1rem;
    }

    .main-controls, .dictation-controls {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1rem;
      flex-wrap: wrap;
    }

    button, .button {
      background-color: var(--accent-color);
      color: white;
      padding: 0.8rem 1.5rem;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      font-weight: 500;
      transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.5rem;
      position: relative;
    }
    
    .button.secondary, button.secondary { background-color: #6c757d; }
    .button.secondary:hover, button.secondary:hover { background-color: #5a6268; }
    
    .button.icon-btn, button.icon-btn {
        padding: 0;
        width: 40px;
        height: 40px;
        font-size: 1.25rem;
        background-color: #e9ecef;
        color: var(--text-secondary);
        border-radius: 50%;
    }
    .button.icon-btn:hover, button.icon-btn:hover {
        background-color: #dee2e6;
        color: var(--text-primary);
        transform: none;
        box-shadow: none;
    }

    button:hover:not(:disabled), .button:hover:not(:disabled) {
      background-color: var(--accent-hover);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(0,0,0,0.1);
    }

    button:disabled {
      background-color: #adb5bd;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .status-message {
      margin-top: 1.5rem;
      font-weight: 500;
      min-height: 1.5em;
      transition: color 0.3s ease;
    }

    .status-message.error { color: var(--error-color); }
    .status-message.info { color: var(--text-secondary); }

    /* MODAL STYLES */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.3s ease;
    }
    .modal-overlay.visible {
        opacity: 1;
        pointer-events: auto;
    }
    .modal-content {
        background-color: var(--surface-color);
        padding: 2rem;
        border-radius: 12px;
        box-shadow: 0 8px 32px var(--shadow-medium);
        width: 100%;
        max-width: 500px;
        transform: scale(0.95);
        transition: transform 0.3s ease;
        position: relative;
    }
    .modal-overlay.visible .modal-content {
        transform: scale(1);
    }
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1.5rem;
        padding-bottom: 1rem;
        border-bottom: 1px solid var(--border-color);
    }
    .modal-header h2 {
        margin: 0;
        font-size: 1.5rem;
    }
    .close-modal-btn {
        background: none;
        border: none;
        font-size: 1.5rem;
        cursor: pointer;
        color: var(--text-secondary);
        padding: 0.5rem;
        line-height: 1;
    }
    .modal-body p {
        color: var(--text-secondary);
        margin-bottom: 1rem;
        text-align: left;
    }
    .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 0.5rem;
        margin-top: 1.5rem;
    }
    .api-key-tip {
        font-size: 0.9rem;
        color: var(--text-secondary);
        margin-bottom: 1rem;
        text-align: left;
    }
    .api-key-tip a {
        color: var(--accent-color);
        text-decoration: none;
        font-weight: 500;
    }
    .api-key-tip a:hover {
        text-decoration: underline;
    }
    
    /* HISTORY MODAL */
    .history-list {
        list-style: none;
        max-height: 60vh;
        overflow-y: auto;
    }
    .history-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem;
        border-radius: 8px;
        transition: background-color 0.2s;
    }
    .history-item:hover {
        background-color: var(--bg-color);
    }
    .history-item-info {
        display: flex;
        flex-direction: column;
        text-align: left;
    }
    .history-item-topic {
        font-weight: 500;
        margin-bottom: 0.25rem;
    }
    .history-item-meta {
        font-size: 0.85rem;
        color: var(--text-secondary);
    }
    .history-item-actions button {
        margin-left: 0.5rem;
        font-size: 0.9rem;
        padding: 0.5rem 1rem;
    }
    .no-history {
        color: var(--text-secondary);
        padding: 2rem 0;
    }


    /* View Transitions */
    .view {
      transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
    }
    .view.hidden {
      opacity: 0;
      transform: scale(0.98);
      pointer-events: none;
      position: absolute;
      width: calc(100% - 5rem); /* Match container padding */
    }

    .mode-selection-container {
      display: flex;
      justify-content: center;
      gap: 2rem;
      flex-wrap: wrap;
    }
    
    .mode-card {
      border: 1px solid var(--border-color);
      border-radius: 12px;
      padding: 2rem;
      width: 100%;
      max-width: 320px;
      cursor: pointer;
      transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
      text-align: left;
    }
    
    .mode-card:hover {
      transform: translateY(-5px);
      box-shadow: 0 8px 25px var(--shadow-light);
      border-color: var(--accent-color);
    }
    
    .mode-card h2 { margin-top: 0; color: var(--accent-color); }
    .mode-card p { color: var(--text-secondary); margin-bottom: 0; font-size: 0.95rem; }
    
    .back-button {
      background: #e9ecef;
      border: none;
      color: var(--text-secondary);
      font-size: 1rem;
      cursor: pointer;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }
    .back-button:hover { background-color: #dee2e6; color: var(--text-primary); }

    .mode-container-header {
      display: flex;
      align-items: center;
      gap: 1rem;
      margin-bottom: 1.5rem;
    }
    .mode-container-header h2 {
      font-size: 1.5rem;
    }

    .flashcards-container {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      justify-content: center;
    }

    .flashcard {
      background-color: transparent;
      width: 250px;
      height: 180px;
      cursor: pointer;
      perspective: 1000px;
    }

    .flashcard-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.7s;
      transform-style: preserve-3d;
      box-shadow: 0 4px 15px var(--shadow-light);
      border-radius: 10px;
    }

    .flashcard.flipped .flashcard-inner { transform: rotateY(180deg); }

    .flashcard-front, .flashcard-back {
      position: absolute;
      width: 100%;
      height: 100%;
      -webkit-backface-visibility: hidden;
      backface-visibility: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background-color: var(--surface-color);
    }
    
    .flashcard.flipped .flashcard-back { border-color: var(--accent-color); }
    .flashcard-back { transform: rotateY(180deg); }
    .term { font-size: 1.25em; font-weight: 500; }
    .definition { font-size: 1em; color: var(--text-secondary); line-height: 1.4; }
    
    .quiz-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 1.5rem;
      max-width: 600px;
      margin: 0 auto;
    }

    .quiz-card {
      width: 100%;
      min-height: 160px;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid var(--border-color);
      background-color: var(--surface-color);
      box-shadow: 0 4px 15px var(--shadow-light);
    }
    
    .quiz-answer-input, .dictation-answer-input {
      width: 100%;
      padding: 0.8rem 1rem;
      font-size: 1rem;
      border: 1px solid var(--border-color);
      border-radius: 8px;
    }
    
    .quiz-feedback { width: 100%; padding: 1rem; border-radius: 8px; text-align: left; line-height: 1.5; }
    .quiz-feedback.correct { background-color: #e8f5e9; border: 1px solid var(--correct-color); }
    .quiz-feedback.partial { background-color: #fff8e1; border: 1px solid #d1a55d; }
    .quiz-feedback.incorrect { background-color: #fce4e4; border: 1px solid var(--error-color); }
    .quiz-feedback strong { display: block; margin-bottom: 0.5rem; font-size: 1.1rem; }
    .quiz-feedback strong.correct { color: var(--correct-color); }
    .quiz-feedback strong.partial { color: #d1a55d; }
    .quiz-feedback strong.incorrect { color: var(--error-color); }

    .progress-text { font-size: 1.1rem; font-weight: 500; margin-bottom: 1rem; }
    
    .dictation-listen-button { font-size: 2.5rem; padding: 1.5rem; border-radius: 50%; width: 80px; height: 80px; }

    .dictation-results-table {
      width: 100%; margin-top: 1.5rem; border-collapse: collapse; text-align: left;
    }
    .dictation-results-table th, .dictation-results-table td {
      padding: 0.75rem 1rem; border-bottom: 1px solid var(--border-color);
    }
    .dictation-results-table th { font-weight: 700; background-color: var(--bg-color); }
    .dictation-results-table tr:last-child td { border-bottom: none; }
    .dictation-results-table .status-correct { color: var(--correct-color); }
    .dictation-results-table .status-incorrect { color: var(--error-color); }
    .dictation-results-table .correct-answer-feedback { font-size: 0.85em; color: var(--text-secondary); margin-top: 0.25rem; }

    .hidden { display: none !important; }
    
    .spinner {
      border: 3px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: #fff;
      width: 20px;
      height: 20px;
      animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    button .button-text.hidden { display: none; }
    
    .study-options-container {
      display: flex;
      justify-content: center;
      gap: 0.5rem;
      background-color: var(--bg-color);
      padding: 0.5rem;
      border-radius: 8px;
      margin: 1rem auto 0;
    }

    .study-option-btn {
      background: none;
      border: 1px solid transparent;
      color: var(--text-secondary);
      font-weight: 500;
      padding: 0.5rem 1rem;
      border-radius: 6px;
      transition: all 0.2s ease;
    }

    .study-option-btn.active {
      background-color: var(--surface-color);
      color: var(--accent-color);
      box-shadow: 0 2px 5px var(--shadow-light);
      border-color: var(--border-color);
    }
    
    /* DICTATION PAGE STYLES */
    .dictation-page-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: var(--bg-color);
        display: flex;
        justify-content: center;
        align-items: center;
        flex-direction: column;
        padding: 1rem;
        z-index: 100;
        opacity: 0;
        transform: scale(1.02);
        pointer-events: none;
        transition: opacity 0.4s ease, transform 0.4s ease;
    }
    .dictation-page-container.visible {
        opacity: 1;
        transform: scale(1);
        pointer-events: auto;
    }
    .dictation-page-content {
        position: relative;
        background-color: var(--surface-color);
        padding: 2.5rem;
        border-radius: 16px;
        box-shadow: 0 8px 32px var(--shadow-light);
        width: 100%;
        max-width: 600px;
        text-align: center;
    }
    .dictation-page-back-button {
        position: absolute;
        top: 1.25rem;
        left: 1.25rem;
    }
    .dictation-translation {
        font-size: 1.2rem;
        color: var(--text-secondary);
        margin-bottom: 1.5rem;
        font-family: var(--font-family-zh);
    }
    .dictation-feedback {
        margin-top: 1rem;
        font-weight: 500;
        min-height: 1.5em;
    }

    /* MATCH GAME STYLES */
    .match-game-container {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        gap: 1rem;
        max-width: 700px;
        margin: 1rem auto 0;
        perspective: 1000px;
    }
    .match-card {
        background-color: var(--surface-color);
        border-radius: 8px;
        height: 100px;
        display: flex;
        justify-content: center;
        align-items: center;
        text-align: center;
        padding: 0.5rem;
        cursor: pointer;
        position: relative;
        transform-style: preserve-3d;
        transition: transform 0.6s, box-shadow 0.3s;
        border: 1px solid var(--border-color);
        box-shadow: 0 2px 8px var(--shadow-light);
    }
    .match-card-content {
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        transform: rotateY(180deg);
        font-size: 0.9rem;
    }
    .match-card::before { /* Card back */
        content: '';
        position: absolute;
        top: 0; left: 0; right: 0; bottom: 0;
        background-color: var(--accent-color);
        -webkit-backface-visibility: hidden;
        backface-visibility: hidden;
        border-radius: 8px;
        transition: background-color 0.2s;
    }
     .match-card:hover::before {
        background-color: var(--accent-hover);
    }
    .match-card.flipped {
        transform: rotateY(180deg);
    }
    .match-card.matched {
        cursor: default;
        border-color: var(--correct-color);
        box-shadow: 0 0 10px rgba(25, 135, 84, 0.3);
        transform: rotateY(180deg);
    }
    .match-card.mismatched {
      border-color: var(--error-color);
    }
    .match-card.flipped.matched::before {
        background-color: #e8f5e9;
    }
    .match-completion-message {
        margin-top: 2rem;
    }
    
    footer {
        text-align: center;
        color: var(--text-secondary);
        font-size: 0.85rem;
        padding: 1rem;
    }

    @media (max-width: 768px) {
      body { padding: 1rem 0.5rem; }
      .container { padding: 1.5rem; }
      h1 { font-size: 1.8rem; }
      .header-actions { margin-left: auto; }
      .main-controls, .dictation-controls { flex-direction: column; gap: 1rem; align-items: stretch; }
      .flashcard { width: 100%; max-width: 300px; }
      .mode-selection-container { flex-direction: column; align-items: center; }
      .dictation-page-content { padding: 1.5rem; }
      .view.hidden { width: calc(100% - 3rem); }

      /* Responsive Dictation Table */
      .dictation-results-table thead {
        display: none;
      }
      .dictation-results-table, .dictation-results-table tbody, .dictation-results-table tr, .dictation-results-table td {
        display: block;
        width: 100%;
      }
      .dictation-results-table tr {
        margin-bottom: 1rem;
        border: 1px solid var(--border-color);
        border-radius: 8px;
        padding: 0.5rem;
      }
      .dictation-results-table td {
        display: flex;
        justify-content: space-between;
        padding: 0.5rem;
        border: none;
        text-align: right;
        align-items: center;
      }
      .dictation-results-table td::before {
        content: attr(data-label);
        font-weight: 500;
        text-align: left;
        margin-right: 1rem;
        color: var(--text-primary);
      }
      .dictation-results-table td:last-child {
        font-size: 1.25rem;
      }
    }
  </style>
</head>
<body>
  <div class="container" id="appContainer">
    <header class="app-header">
      <div class="header-main">
        <h1 data-translate-key="appTitle">Flipcard Study</h1>
        <div class="header-actions">
            <div class="language-switcher">
              <button class="lang-button" data-lang="en">EN</button>
              <button class="lang-button" data-lang="zh-HK">‰∏≠</button>
            </div>
            <button id="historyButton" class="icon-btn" aria-label="Open study history">üïí</button>
            <button id="settingsButton" class="icon-btn" aria-label="Open settings">‚öôÔ∏è</button>
        </div>
      </div>
      <p data-translate-key="appDescription">Generate study cards for your HKDSE prep or run vocabulary dictation drills. Pick a mode to get started!</p>
    </header>

    <main id="mainContent">
      <!-- MODE SELECTION -->
      <div id="modeSelectionContainer" class="view mode-selection-container">
          <div class="mode-card" id="selectStudyMode">
              <h2 data-translate-key="studyModeTitle">üìö Study Mode</h2>
              <p data-translate-key="studyModeDescription">Enter a topic and AI will generate flashcards and a quiz for you.</p>
          </div>
          <div class="mode-card" id="selectDictationMode">
              <h2 data-translate-key="dictationModeTitle">üéß Dictation Mode</h2>
              <p data-translate-key="dictationModeDescription">Input your vocabulary list and test yourself with audio dictation.</p>
          </div>
      </div>

      <!-- STUDY MODE -->
      <div id="studyModeContainer" class="view hidden">
        <div class="mode-container-header">
          <button class="back-button" aria-label="Back to mode selection">‚Üê</button>
          <h2 data-translate-key="studyModeTitle">Study Mode</h2>
        </div>
        <textarea id="topicInput" class="text-input" data-translate-key="studyTopicPlaceholder" placeholder="Enter a topic, e.g., 'Photosynthesis' or 'Medieval Europe'"></textarea>
        <div class="main-controls">
          <button id="generateButton">
            <span class="button-text" data-translate-key="generateButton">Generate Flashcards</span>
            <span class="spinner hidden"></span>
          </button>
          <button id="generateFromNoteButton">
             <span class="button-text" data-translate-key="generateFromNoteButton">Generate from Note</span>
             <span class="spinner hidden"></span>
          </button>
          <button id="importButton" class="secondary" data-translate-key="importButton">Import Cards</button>
          <button id="exportButton" class="secondary hidden" data-translate-key="exportButton">Export Cards</button>
        </div>
         <div class="study-options-container hidden" id="studyOptionsContainer">
           <button class="study-option-btn active" data-mode="study" data-translate-key="studyModeLabel">Study</button>
           <button class="study-option-btn" data-mode="quiz" data-translate-key="quizModeLabel">Quiz</button>
           <button class="study-option-btn" data-mode="match" data-translate-key="matchModeLabel">Match</button>
         </div>
      </div>
      
      <!-- DICTATION MODE -->
      <div id="dictationModeContainer" class="view hidden">
        <div class="mode-container-header">
            <button class="back-button" aria-label="Back to mode selection">‚Üê</button>
            <h2 data-translate-key="dictationModeTitle">Dictation Mode</h2>
        </div>
        <textarea id="dictationListInput" data-translate-key="dictationListPlaceholder" placeholder="Enter your vocabulary list here. Any format is okay - AI will clean it up for you."></textarea>
        <div class="dictation-controls">
            <button id="translateButton">
                <span class="button-text" data-translate-key="translateButton">Translate to Chinese</span>
                <span class="spinner hidden"></span>
            </button>
            <button id="startDictationButton">
                <span class="button-text" data-translate-key="startDictationButton">Start Dictation</span>
                <span class="spinner hidden"></span>
            </button>
        </div>
      </div>
    </main>
    
    <div id="statusMessage" class="status-message"></div>
    <div id="content-area">
      <!-- Dynamic content (flashcards or quiz) will be injected here -->
    </div>
  </div>

  <!-- DICTATION PAGE -->
  <div id="dictationPage" class="dictation-page-container">
    <!-- Dictation practice/results will be injected here -->
  </div>

  <!-- MODALS -->
  <div id="apiKeyModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h2 data-translate-key="settingsTitle">Settings</h2>
        <button class="close-modal-btn" data-target-modal="apiKeyModal" aria-label="Close settings">√ó</button>
      </div>
      <div class="modal-body">
        <p data-translate-key="apiKeyModalDescription">Your Google AI API Key is stored only in your browser's local storage.</p>
        <p class="api-key-tip">
          <span data-translate-key="apiKeyTip">Tip: Get your API key from </span>
          <a href="https://aistudio.google.com/apikey" target="_blank" rel="noopener noreferrer">Google AI Studio</a>.
        </p>
        <input type="password" id="apiKeyModalInput" class="text-input" data-translate-key="apiKeyPlaceholder" placeholder="Enter your Google AI API Key here">
      </div>
      <div class="modal-footer">
        <button id="saveApiKeyButton" data-translate-key="saveButton">Save</button>
      </div>
    </div>
  </div>

  <div id="historyModal" class="modal-overlay">
    <div class="modal-content">
      <div class="modal-header">
        <h2 data-translate-key="historyTitle">Study History</h2>
        <button class="close-modal-btn" data-target-modal="historyModal" aria-label="Close history">√ó</button>
      </div>
      <div class="modal-body" id="historyModalBody">
        <!-- History items will be injected here -->
      </div>
    </div>
  </div>

  <input type="file" id="importInput" class="hidden" accept=".json">
  <input type="file" id="noteInput" class="hidden" accept=".txt,.md,.pdf,.doc,.docx,.ppt,.pptx,image/*">
  
  <footer>
    Copyright ¬© 2025 Hugo Wong. All rights reserved.
  </footer>

  <script type="module">
    import { GoogleGenAI, Type } from "@google/genai";

    // --- I18n Translations ---
    const translations = {
        en: {
            appTitle: "Flipcard Study",
            appDescription: "Generate study cards for your HKDSE prep or run vocabulary dictation drills. Pick a mode to get started!",
            apiKeyPlaceholder: "Enter your Google AI API Key here",
            studyModeTitle: "üìö Study Mode",
            studyModeDescription: "Enter a topic, upload a note, and AI will generate flashcards for you.",
            dictationModeTitle: "üéß Dictation Mode",
            dictationModeDescription: "Input your vocabulary list and test yourself with audio dictation.",
            studyTopicPlaceholder: "Enter a topic, e.g., 'Photosynthesis' or 'Medieval Europe'",
            generateButton: "Generate Flashcards",
            generateFromNoteButton: "Generate from Note",
            importButton: "Import",
            exportButton: "Export",
            studyModeLabel: "Study",
            quizModeLabel: "Quiz",
            matchModeLabel: "Match",
            dictationListPlaceholder: "Enter your vocabulary list here. Any format is okay - AI will clean it up for you.",
            translateButton: "Translate to Chinese",
            startDictationButton: "Start Dictation",
            statusGenerating: "Generating flashcards for you...",
            statusAnalyzing: "Analyzing your file...",
            statusTranslating: "Translating your list...",
            statusParsing: "Cleaning up your list...",
            errorApiKey: "Please set your Google AI API Key in Settings (‚öôÔ∏è).",
            errorTopic: "Please enter a topic.",
            errorNoFile: "Please select a file.",
            errorFileRead: "Could not read the file.",
            errorNoCards: "Could not generate flashcards. Please try a different topic.",
            errorGeneral: "An error occurred: ",
            errorUnknown: "Unknown error",
            errorImport: "Import failed: ",
            errorNoExport: "No cards to export.",
            errorImportInvalidJSON: "Import failed: The file is not a valid JSON.",
            errorImportInvalidStructure: "Import failed: Each flashcard must have a 'term' and a 'definition'.",
            errorSpeechSynthesis: "Your browser does not support speech synthesis.",
            errorDictationList: "Please enter a vocabulary list.",
            errorNoValidWords: "No valid words found in your list.",
            quizQuestion: "Question",
            quizScore: "Score",
            quizAnswerPlaceholder: "Type your answer here...",
            submitAnswerButton: "Submit Answer",
            evaluatingAnswer: "Evaluating...",
            nextQuestionButton: "Next Question",
            quizCompleteTitle: "Quiz Complete!",
            finalScore: "Your final score",
            restartQuizButton: "Restart Quiz",
            dictationWord: "Word",
            checkButton: "Check",
            nextWordButton: "Next ‚Üí",
            dictationCompleteTitle: "Dictation Complete!",
            correctWord: "Correct Word",
            yourAnswer: "Your Answer",
            status: "Status",
            practiceAgainButton: "Practice Again",
            backToMenuButton: "Back to Main Menu",
            backButtonLabel: "Back",
            feedbackCorrectAnswerIs: "The correct answer is:",
            matchGameComplete: "Well done!",
            playAgainButton: "Play Again",
            returnToStudyButton: "Return to Study",
            settingsTitle: "Settings",
            apiKeyModalDescription: "Your Google AI API Key is stored only in your browser's local storage.",
            apiKeyTip: "Tip: Get your API key from ",
            saveButton: "Save",
            historyTitle: "Study History",
            noHistoryMessage: "You have no saved study sets yet.",
            loadButton: "Load",
            deleteButton: "Delete",
            cardsLabel: "cards"
        },
        'zh-HK': {
            appTitle: "Ê∫´ÁøíÂç°Â≠∏Áøí",
            appDescription: "ÁÇ∫ÊÇ®ÁöÑÈ¶ôÊ∏Ø‰∏≠Â≠∏ÊñáÊÜëËÄÉË©¶ (HKDSE) ÁîüÊàêÂ≠∏ÁøíÂç°ÊàñÈÄ≤Ë°åË©ûÂΩôËÅΩÂØ´Á∑¥Áøí„ÄÇÈÅ∏Êìá‰∏ÄÁ®ÆÊ®°ÂºèÂç≥ÂèØÈñãÂßãÔºÅ",
            apiKeyPlaceholder: "Âú®Ê≠§ËôïËº∏ÂÖ•ÊÇ®ÁöÑ Google AI API Key",
            studyModeTitle: "üìö Â≠∏ÁøíÊ®°Âºè",
            studyModeDescription: "Ëº∏ÂÖ•‰∏ªÈ°å„ÄÅ‰∏äÂÇ≥Á≠ÜË®òÔºåAI Â∞áÁÇ∫ÊÇ®ÁîüÊàêÊ∫´ÁøíÂç°„ÄÇ",
            dictationModeTitle: "üéß ËÅΩÂØ´Ê®°Âºè",
            dictationModeDescription: "Ëº∏ÂÖ•ÊÇ®ÁöÑË©ûÂΩôÂàóË°®Ôºå‰∏¶ÈÄöÈÅéËÅΩÂØ´Á∑¥Áøí‰æÜÊ∏¨Ë©¶Ëá™Â∑±„ÄÇ",
            studyTopicPlaceholder: "Ëº∏ÂÖ•‰∏ªÈ°åÔºå‰æãÂ¶ÇÔºö‚ÄúÂÖâÂêà‰ΩúÁî®‚ÄùÊàñ‚Äú‰∏≠‰∏ñÁ¥ÄÊ≠êÊ¥≤‚Äù",
            generateButton: "ÁîüÊàêÊ∫´ÁøíÂç°",
            generateFromNoteButton: "ÂæûÁ≠ÜË®òÁîüÊàê",
            importButton: "Â∞éÂÖ•",
            exportButton: "Â∞éÂá∫",
            studyModeLabel: "Â≠∏Áøí",
            quizModeLabel: "Ê∏¨È©ó",
            matchModeLabel: "ÈÖçÂ∞ç",
            dictationListPlaceholder: "Âú®Ê≠§ËôïËº∏ÂÖ•ÊÇ®ÁöÑË©ûÂΩôÂàóË°®„ÄÇ‰ªª‰ΩïÊ†ºÂºèÈÉΩÂèØ‰ª• - AIÊúÉÁÇ∫ÊÇ®Êï¥ÁêÜ„ÄÇ",
            translateButton: "ÁøªË≠ØÁÇ∫‰∏≠Êñá",
            startDictationButton: "ÈñãÂßãËÅΩÂØ´",
            statusGenerating: "Ê≠£Âú®ÁÇ∫ÊÇ®ÁîüÊàêÊ∫´ÁøíÂç°...",
            statusAnalyzing: "Ê≠£Âú®ÂàÜÊûêÊÇ®ÁöÑÊ™îÊ°à...",
            statusTranslating: "Ê≠£Âú®ÁøªË≠ØÊÇ®ÁöÑÂàóË°®...",
            statusParsing: "Ê≠£Âú®Êï¥ÁêÜÊÇ®ÁöÑÂàóË°®...",
            errorApiKey: "Ë´ãÂú®Ë®≠ÂÆö (‚öôÔ∏è) ‰∏≠Ë®≠ÁΩÆÊÇ®ÁöÑ Google AI API Key„ÄÇ",
            errorTopic: "Ë´ãËº∏ÂÖ•‰∏ÄÂÄã‰∏ªÈ°å„ÄÇ",
            errorNoFile: "Ë´ãÈÅ∏Êìá‰∏ÄÂÄãÊñá‰ª∂„ÄÇ",
            errorFileRead: "ÁÑ°Ê≥ïËÆÄÂèñÊñá‰ª∂„ÄÇ",
            errorNoCards: "ÁÑ°Ê≥ïÁîüÊàêÂ≠∏ÁøíÂç°„ÄÇË´ãÂòóË©¶‰∏çÂêåÁöÑ‰∏ªÈ°åÊàñÈáçÊñ∞Êé™Ëæ≠„ÄÇ",
            errorGeneral: "ÁîüÊàêÊôÇÁôºÁîüÈåØË™§: ",
            errorUnknown: "Êú™Áü•ÈåØË™§",
            errorImport: "Â∞éÂÖ•Â§±Êïó: ",
            errorNoExport: "Ê≤íÊúâÂèØÂ∞éÂá∫ÁöÑÊ∫´ÁøíÂç°„ÄÇ",
            errorImportInvalidJSON: "Â∞éÂÖ•Â§±ÊïóÔºöÊñá‰ª∂‰∏çÊòØÊúâÊïàÁöÑJSONÊ†ºÂºè„ÄÇ",
            errorImportInvalidStructure: "Â∞éÂÖ•Â§±ÊïóÔºöÊØèÂºµÊ∫´ÁøíÂç°ÈÉΩÂøÖÈ†àÂåÖÂê´'term'Âíå'definition'„ÄÇ",
            errorSpeechSynthesis: "ÊÇ®ÁöÑÁÄèË¶ΩÂô®‰∏çÊîØÊåÅË™ûÈü≥ÂêàÊàê„ÄÇ",
            errorDictationList: "Ë´ãËº∏ÂÖ•Ë©ûÂΩôÂàóË°®„ÄÇ",
            errorNoValidWords: "ÊÇ®ÁöÑÂàóË°®‰∏≠Êú™ÊâæÂà∞ÊúâÊïàË©ûÂΩô„ÄÇ",
            quizQuestion: "ÂïèÈ°å",
            quizScore: "ÂàÜÊï∏",
            quizAnswerPlaceholder: "Âú®ÈÄôË£°Ëº∏ÂÖ•ÊÇ®ÁöÑÁ≠îÊ°à...",
            submitAnswerButton: "Êèê‰∫§Á≠îÊ°à",
            evaluatingAnswer: "Ë©ï‰º∞‰∏≠...",
            nextQuestionButton: "‰∏ã‰∏ÄÂÄãÂïèÈ°å",
            quizCompleteTitle: "Ê∏¨È©óÂÆåÊàêÔºÅ",
            finalScore: "ÊÇ®ÁöÑÊúÄÁµÇÂàÜÊï∏",
            restartQuizButton: "ÈáçÊñ∞ÈñãÂßãÊ∏¨È©ó",
            dictationWord: "Ë©ûË™û",
            checkButton: "Ê™¢Êü•",
            nextWordButton: "‰∏ã‰∏ÄÂÄã ‚Üí",
            dictationCompleteTitle: "ËÅΩÂØ´ÂÆåÊàêÔºÅ",
            correctWord: "Ê≠£Á¢∫Ë©ûË™û",
            yourAnswer: "ÊÇ®ÁöÑÁ≠îÊ°à",
            status: "ÁãÄÊÖã",
            practiceAgainButton: "ÂÜçÊ¨°Á∑¥Áøí",
            backToMenuButton: "ËøîÂõû‰∏ªËèúÂñÆ",
            backButtonLabel: "ËøîÂõû",
            feedbackCorrectAnswerIs: "Ê≠£Á¢∫Á≠îÊ°àÊòØÔºö",
            matchGameComplete: "ÂÆåÊàêÔºÅ",
            playAgainButton: "ÂÜçÁé©‰∏ÄÊ¨°",
            returnToStudyButton: "ËøîÂõûÂ≠∏Áøí",
            settingsTitle: "Ë®≠ÂÆö",
            apiKeyModalDescription: "ÊÇ®ÁöÑ Google AI API Key ÂÉÖÂÑ≤Â≠òÂú®ÊÇ®ÁÄèË¶ΩÂô®ÁöÑÊú¨Âú∞ÂÑ≤Â≠òÁ©∫Èñì‰∏≠„ÄÇ",
            apiKeyTip: "ÊèêÁ§∫ÔºöÊÇ®ÂèØ‰ª•ÂæûÊ≠§ËôïÁç≤ÂèñÊÇ®ÁöÑ API Key ",
            saveButton: "ÂÑ≤Â≠ò",
            historyTitle: "Â≠∏ÁøíË®òÈåÑ",
            noHistoryMessage: "ÊÇ®ÈÇÑÊ≤íÊúâÂ∑≤ÂÑ≤Â≠òÁöÑÂ≠∏ÁøíÈõÜ„ÄÇ",
            loadButton: "ËºâÂÖ•",
            deleteButton: "Âà™Èô§",
            cardsLabel: "ÂºµÂç°"
        }
    };
    let currentLanguage = 'en';

    // --- DOM Elements ---
    const appContainer = document.getElementById('appContainer');
    const statusMessage = document.getElementById('statusMessage');
    const contentArea = document.getElementById('content-area');

    // View Containers
    const modeSelectionContainer = document.getElementById('modeSelectionContainer');
    const studyModeContainer = document.getElementById('studyModeContainer');
    const dictationModeContainer = document.getElementById('dictationModeContainer');
    const dictationPage = document.getElementById('dictationPage');

    // Mode Selection
    const selectStudyMode = document.getElementById('selectStudyMode');
    const selectDictationMode = document.getElementById('selectDictationMode');
    
    // Study Mode Elements
    const topicInput = document.getElementById('topicInput');
    const generateButton = document.getElementById('generateButton');
    const generateFromNoteButton = document.getElementById('generateFromNoteButton');
    const importButton = document.getElementById('importButton');
    const exportButton = document.getElementById('exportButton');
    const importInput = document.getElementById('importInput');
    const noteInput = document.getElementById('noteInput');
    const studyOptionsContainer = document.getElementById('studyOptionsContainer');
    
    // Dictation Mode Elements
    const dictationListInput = document.getElementById('dictationListInput');
    const startDictationButton = document.getElementById('startDictationButton');
    const translateButton = document.getElementById('translateButton');
    
    // Modals
    const apiKeyModal = document.getElementById('apiKeyModal');
    const apiKeyModalInput = document.getElementById('apiKeyModalInput');
    const saveApiKeyButton = document.getElementById('saveApiKeyButton');
    const historyModal = document.getElementById('historyModal');
    const historyModalBody = document.getElementById('historyModalBody');
    const settingsButton = document.getElementById('settingsButton');
    const historyButton = document.getElementById('historyButton');


    // --- State ---
    let ai = null;
    let apiKey = '';
    let flashcards = [];
    let currentStudyMode = 'study';
    let quizIndex = 0;
    let quizScore = 0;
    let maxQuizScore = 0;
    let dictationWords = []; // Will now be an array of objects {english, chinese}
    let userAnswers = [];
    let currentDictationIndex = 0;

    // --- Utility Functions ---
    const getTranslation = (key) => translations[currentLanguage][key] || key;

    function showStatus(key, type = 'info') {
      statusMessage.textContent = key ? getTranslation(key) : '';
      statusMessage.className = 'status-message';
      if (type) {
        statusMessage.classList.add(type);
      }
    }
    
    function toggleLoading(button, isLoading) {
        if (!button) return;
        button.disabled = isLoading;
        const buttonText = button.querySelector('.button-text');
        const spinner = button.querySelector('.spinner');
        if (isLoading) {
            buttonText?.classList.add('hidden');
            spinner?.classList.remove('hidden');
        } else {
            buttonText?.classList.remove('hidden');
            spinner?.classList.add('hidden');
        }
    }

    const fileToBase64 = (file) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => resolve(reader.result.split(',')[1]);
        reader.onerror = error => reject(error);
    });

    // --- I18n Functions ---
    function setLanguage(lang) {
        if (!translations[lang]) return;
        currentLanguage = lang;
        localStorage.setItem('userLanguage', lang);

        document.documentElement.lang = lang;
        
        document.querySelectorAll('[data-translate-key]').forEach(el => {
            const key = el.getAttribute('data-translate-key');
            const translation = getTranslation(key);
            if (el.placeholder) {
                el.placeholder = translation;
            } else {
                el.textContent = translation;
            }
        });
        
        document.querySelectorAll('.lang-button').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.lang === lang);
        });
    }

    function initializeLanguage() {
        const savedLang = localStorage.getItem('userLanguage');
        const browserLang = navigator.language.startsWith('zh') ? 'zh-HK' : 'en';
        setLanguage(savedLang || browserLang);
    }

    // --- Initialization ---
    function initialize() {
        loadApiKey();
        setupEventListeners();
        updateButtonStates();
        initializeLanguage();
    }
    
    function setupEventListeners() {
        document.querySelectorAll('.lang-button').forEach(btn => {
            btn.addEventListener('click', () => setLanguage(btn.dataset.lang));
        });
        
        selectStudyMode.addEventListener('click', () => showView('study'));
        selectDictationMode.addEventListener('click', () => showView('dictation'));
        document.querySelectorAll('.back-button').forEach(btn => {
            btn.addEventListener('click', () => {
                showView('selection');
                resetStudyMode();
            });
        });
        
        generateButton.addEventListener('click', generateFlashcards);
        generateFromNoteButton.addEventListener('click', () => noteInput.click());
        noteInput.addEventListener('change', handleNoteUpload);
        importButton.addEventListener('click', () => importInput.click());
        exportButton.addEventListener('click', exportFlashcards);
        importInput.addEventListener('change', importFlashcards);
        
        studyOptionsContainer.addEventListener('click', (e) => {
            if (e.target.classList.contains('study-option-btn')) {
                handleStudyModeChange(e.target.dataset.mode);
            }
        });
        
        startDictationButton.addEventListener('click', startDictation);
        translateButton.addEventListener('click', translateVocabulary);

        // Modal listeners
        settingsButton.addEventListener('click', () => toggleModal('apiKeyModal', true));
        historyButton.addEventListener('click', () => {
            renderHistoryModal();
            toggleModal('historyModal', true);
        });
        saveApiKeyButton.addEventListener('click', handleSaveApiKey);
        document.querySelectorAll('.close-modal-btn').forEach(btn => {
            btn.addEventListener('click', () => toggleModal(btn.dataset.targetModal, false));
        });
        document.querySelectorAll('.modal-overlay').forEach(overlay => {
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    toggleModal(overlay.id, false);
                }
            });
        });
    }
    
    function updateButtonStates() {
      const hasApiKey = apiKey.trim().length > 0;
      generateButton.disabled = !hasApiKey;
      generateFromNoteButton.disabled = !hasApiKey;
      startDictationButton.disabled = !hasApiKey;
      translateButton.disabled = !hasApiKey;
    }

    // --- View & Modal Management ---
    function showView(viewName) {
        [modeSelectionContainer, studyModeContainer, dictationModeContainer].forEach(v => v.classList.add('hidden'));
        contentArea.innerHTML = '';
        showStatus('');

        let viewToShow;
        switch(viewName) {
            case 'study': viewToShow = studyModeContainer; break;
            case 'dictation': viewToShow = dictationModeContainer; break;
            case 'selection':
            default: viewToShow = modeSelectionContainer; break;
        }
        
        setTimeout(() => {
            viewToShow.classList.remove('hidden');
        }, 10);
    }
    
    function showDictationPage(show) {
        if (show) {
            appContainer.classList.add('hidden');
            dictationPage.classList.add('visible');
        } else {
            appContainer.classList.remove('hidden');
            dictationPage.classList.remove('visible');
        }
    }
    
    function toggleModal(modalId, show) {
        const modal = document.getElementById(modalId);
        if (modal) {
            modal.classList.toggle('visible', show);
        }
    }

    // --- API Key & AI Initialization ---
    function loadApiKey() {
        apiKey = localStorage.getItem('googleGenAiApiKey') || '';
        apiKeyModalInput.value = apiKey;
        if (apiKey) {
            initializeAi();
        }
    }

    function handleSaveApiKey() {
        apiKey = apiKeyModalInput.value.trim();
        localStorage.setItem('googleGenAiApiKey', apiKey);
        initializeAi();
        updateButtonStates();
        toggleModal('apiKeyModal', false);
    }

    function initializeAi() {
        if (!apiKey) {
            ai = null;
            return false;
        }
        try {
            ai = new GoogleGenAI({ apiKey });
            return true;
        } catch(e) {
            showStatus('errorApiKey', 'error');
            return false;
        }
    }
    
    // --- History Management ---
    function getHistory() {
        return JSON.parse(localStorage.getItem('studyHistory') || '[]');
    }

    function saveToHistory(topic, cards) {
        const history = getHistory();
        const newEntry = {
            id: Date.now(),
            topic,
            date: new Date().toISOString(),
            cards
        };
        history.unshift(newEntry); // Add to the beginning
        if (history.length > 50) { // Limit history size
            history.pop();
        }
        localStorage.setItem('studyHistory', JSON.stringify(history));
    }

    function deleteFromHistory(id) {
        let history = getHistory();
        history = history.filter(item => item.id !== id);
        localStorage.setItem('studyHistory', JSON.stringify(history));
        renderHistoryModal();
    }

    function loadFromHistory(id) {
        const history = getHistory();
        const entry = history.find(item => item.id === id);
        if (entry) {
            flashcards = entry.cards;
            topicInput.value = entry.topic;
            showView('study');
            studyOptionsContainer.classList.remove('hidden');
            exportButton.classList.remove('hidden');
            handleStudyModeChange('study');
            toggleModal('historyModal', false);
        }
    }

    function renderHistoryModal() {
        const history = getHistory();
        if (history.length === 0) {
            historyModalBody.innerHTML = `<p class="no-history">${getTranslation('noHistoryMessage')}</p>`;
            return;
        }
        historyModalBody.innerHTML = `<ul class="history-list"></ul>`;
        const list = historyModalBody.querySelector('.history-list');
        history.forEach(item => {
            const li = document.createElement('li');
            li.className = 'history-item';
            const date = new Date(item.date).toLocaleDateString(currentLanguage, { year: 'numeric', month: 'short', day: 'numeric' });
            li.innerHTML = `
                <div class="history-item-info">
                    <span class="history-item-topic">${item.topic}</span>
                    <span class="history-item-meta">${date} - ${item.cards.length} ${getTranslation('cardsLabel')}</span>
                </div>
                <div class="history-item-actions">
                    <button class="load-history-btn" data-id="${item.id}">${getTranslation('loadButton')}</button>
                    <button class="delete-history-btn secondary" data-id="${item.id}">${getTranslation('deleteButton')}</button>
                </div>`;
            list.appendChild(li);
        });

        list.querySelectorAll('.load-history-btn').forEach(btn => {
            btn.addEventListener('click', () => loadFromHistory(Number(btn.dataset.id)));
        });
        list.querySelectorAll('.delete-history-btn').forEach(btn => {
            btn.addEventListener('click', () => deleteFromHistory(Number(btn.dataset.id)));
        });
    }

    function resetStudyMode() {
        flashcards = [];
        studyOptionsContainer.classList.add('hidden');
        exportButton.classList.add('hidden');
        currentStudyMode = 'study';
        contentArea.innerHTML = '';
        topicInput.value = '';
    }

    // --- Study Mode Functions ---
    async function generateFlashcards() {
      if (!initializeAi()) { showStatus('errorApiKey', 'error'); return; }
      
      const topic = topicInput.value.trim();
      if (!topic) {
        showStatus('errorTopic', 'error');
        return;
      }

      showStatus('statusGenerating');
      toggleLoading(generateButton, true);
      resetStudyMode();

      try {
        const prompt = `As an expert tutor for the Hong Kong Diploma of Secondary Education (HKDSE) curriculum, create a set of at least 5 flashcards for the topic "${topic}". The terms and definitions should be clear, concise, and directly relevant to the HKDSE syllabus.`;
        const result = await ai.models.generateContent({
            model: 'gemini-2.5-flash',
            contents: { parts: [{ text: prompt }] },
            config: {
                responseMimeType: "application/json",
                responseSchema: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: { term: { type: Type.STRING }, definition: { type: Type.STRING } } } }
            }
        });
        const parsedFlashcards = JSON.parse(result.text);

        if (parsedFlashcards && parsedFlashcards.length > 0) {
          flashcards = parsedFlashcards;
          saveToHistory(topic, flashcards);
          showStatus('');
          studyOptionsContainer.classList.remove('hidden');
          exportButton.classList.remove('hidden');
          handleStudyModeChange('study');
        } else {
          showStatus('errorNoCards', 'error');
        }
      } catch (error) {
        console.error('Error generating content:', error);
        showStatus(getTranslation('errorGeneral') + (error.message || getTranslation('errorUnknown')), 'error');
      } finally {
        toggleLoading(generateButton, false);
      }
    }

    async function handleNoteUpload(event) {
        const file = event.target.files[0];
        if (!file) {
            showStatus('errorNoFile', 'error');
            return;
        }
        
        if (!initializeAi()) { showStatus('errorApiKey', 'error'); return; }

        showStatus('statusAnalyzing');
        toggleLoading(generateFromNoteButton, true);
        resetStudyMode();
        const topic = file.name;
        topicInput.value = topic;
        
        try {
            let contents;
            if (file.type.startsWith('text/')) {
                const textContent = await file.text();
                const prompt = `Based on the following notes about "${topic}", create a set of flashcards. Each flashcard should have a 'term' and a 'definition'. The content should be extracted and summarized from the notes provided. Notes: """${textContent}"""`;
                contents = { parts: [{ text: prompt }] };
            } else {
                // Handle images, PDFs, etc.
                const base64Data = await fileToBase64(file);
                const filePart = {
                    inlineData: {
                        mimeType: file.type,
                        data: base64Data,
                    },
                };
                const textPart = { text: `Extract key terms and definitions from the provided file (${topic}) to create flashcards suitable for an HKDSE student.` };
                contents = { parts: [filePart, textPart] };
            }

             const result = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents,
                config: {
                    responseMimeType: "application/json",
                    responseSchema: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: { term: { type: Type.STRING }, definition: { type: Type.STRING } } } }
                }
            });
            const parsedFlashcards = JSON.parse(result.text);

            if (parsedFlashcards && parsedFlashcards.length > 0) {
                flashcards = parsedFlashcards;
                saveToHistory(topic, flashcards);
                showStatus('');
                studyOptionsContainer.classList.remove('hidden');
                exportButton.classList.remove('hidden');
                handleStudyModeChange('study');
            } else {
                showStatus('errorNoCards', 'error');
            }
        } catch (error) {
            console.error('Error generating from note:', error);
            showStatus(getTranslation('errorGeneral') + (error.message || getTranslation('errorUnknown')), 'error');
        } finally {
            toggleLoading(generateFromNoteButton, false);
            event.target.value = ''; // Reset file input
        }
    }

    function exportFlashcards() {
      if (flashcards.length === 0) {
        showStatus('errorNoExport', 'error');
        return;
      }
      const topic = topicInput.value.trim().replace(/\s+/g, '_') || 'flashcards';
      const fileName = `flashcards-${topic}.json`;
      const dataStr = JSON.stringify(flashcards, null, 2);
      const dataBlob = new Blob([dataStr], { type: 'application/json' });
      const url = URL.createObjectURL(dataBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function importFlashcards(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          let importedData;
          try {
            importedData = JSON.parse(e.target.result);
          } catch(jsonError) {
             throw new Error(getTranslation('errorImportInvalidJSON'));
          }
          
          if (!Array.isArray(importedData) || importedData.some(item => !item.term || !item.definition)) {
            throw new Error(getTranslation('errorImportInvalidStructure'));
          }
          flashcards = importedData;
          const topic = file.name.replace('.json', '') || 'Imported Flashcards';
          topicInput.value = topic;
          saveToHistory(topic, flashcards);
          showStatus('');
          studyOptionsContainer.classList.remove('hidden');
          exportButton.classList.remove('hidden');
          handleStudyModeChange('study');
        } catch (error) {
          showStatus(getTranslation('errorImport') + error.message, 'error');
        } finally {
          event.target.value = '';
        }
      };
      reader.readAsText(file);
    }

    function handleStudyModeChange(mode) {
      if (flashcards.length === 0) return;
      currentStudyMode = mode;
      
      document.querySelectorAll('.study-option-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === mode);
      });
      renderStudyContent();
    }
    
    function renderStudyContent() {
        contentArea.innerHTML = '';
        switch(currentStudyMode) {
            case 'study':
                renderStudyMode();
                break;
            case 'quiz':
                quizIndex = 0;
                quizScore = 0;
                maxQuizScore = flashcards.length * 2;
                renderQuizMode();
                break;
            case 'match':
                renderMatchGame();
                break;
        }
    }

    function renderStudyMode() {
      const container = document.createElement('div');
      container.className = 'flashcards-container';
      flashcards.forEach(cardData => {
        const cardEl = document.createElement('div');
        cardEl.className = 'flashcard';
        cardEl.innerHTML = `<div class="flashcard-inner"><div class="flashcard-front"><div class="term">${cardData.term}</div></div><div class="flashcard-back"><div class="definition">${cardData.definition}</div></div></div>`;
        cardEl.addEventListener('click', () => cardEl.classList.toggle('flipped'));
        container.appendChild(cardEl);
      });
      contentArea.appendChild(container);
    }
    
    function renderQuizMode() {
        if (quizIndex >= flashcards.length) {
            renderQuizEndScreen();
            return;
        }
        const currentCard = flashcards[quizIndex];
        const quizContainer = document.createElement('div');
        quizContainer.className = 'quiz-container';
        quizContainer.innerHTML = `
            <div class="progress-text">${getTranslation('quizQuestion')} ${quizIndex + 1} / ${flashcards.length} | ${getTranslation('quizScore')}: ${quizScore} / ${maxQuizScore}</div>
            <div class="quiz-card"><div class="term">${currentCard.term}</div></div>
            <textarea class="quiz-answer-input" placeholder="${getTranslation('quizAnswerPlaceholder')}"></textarea>
            <button id="submitAnswerBtn">${getTranslation('submitAnswerButton')}</button>
            <div id="quizFeedbackContainer"></div>`;
        contentArea.appendChild(quizContainer);
        quizContainer.querySelector('#submitAnswerBtn').addEventListener('click', () => {
            const answer = quizContainer.querySelector('.quiz-answer-input').value;
            checkQuizAnswer(answer, currentCard);
        });
    }
    
    async function checkQuizAnswer(userAnswer, card) {
        if (!userAnswer.trim() || !initializeAi()) { showStatus('errorApiKey', 'error'); return; }
        const submitBtn = document.getElementById('submitAnswerBtn');
        submitBtn.disabled = true;
        submitBtn.innerHTML = `<span class="spinner"></span> <span data-translate-key="evaluatingAnswer">${getTranslation('evaluatingAnswer')}</span>`;
        const feedbackContainer = document.getElementById('quizFeedbackContainer');
        feedbackContainer.innerHTML = '';
        
        try {
            const prompt = `You are an HKDSE exam marker. The subject is "${topicInput.value}". The question is: "What is ${card.term}?". The model answer is: "${card.definition}". The student's answer is: "${userAnswer}". Is the student's answer correct? Provide a very brief, one-sentence explanation and a score of CORRECT, PARTIAL, or INCORRECT.`;
            const result = await ai.models.generateContent({
              model: 'gemini-2.5-flash',
              contents: { parts: [{ text: prompt }] },
              config: { responseMimeType: "application/json", responseSchema: { type: Type.OBJECT, properties: { evaluation: { type: Type.STRING }, score: { type: Type.STRING } } } }
            });
            const { evaluation, score } = JSON.parse(result.text);
            let scoreClass = 'incorrect';
            if (score.toUpperCase() === 'CORRECT') { scoreClass = 'correct'; quizScore += 2; } 
            else if (score.toUpperCase() === 'PARTIAL') { scoreClass = 'partial'; quizScore += 1; }

            feedbackContainer.innerHTML = `<div class="quiz-feedback ${scoreClass}"><strong class="${scoreClass}">${score.toUpperCase()} (+${score.toUpperCase() === 'CORRECT' ? 2 : (score.toUpperCase() === 'PARTIAL' ? 1 : 0)} pts)</strong><p><strong>Ë©ïÂÉπ:</strong> ${evaluation}</p><p><strong>Ê≠£Á¢∫Á≠îÊ°à:</strong> ${card.definition}</p></div>`;
            submitBtn.disabled = false;
            submitBtn.innerHTML = getTranslation('nextQuestionButton');
            submitBtn.onclick = () => { quizIndex++; renderQuizMode(); };
        } catch (error) {
            console.error('Error evaluating answer:', error);
            feedbackContainer.innerHTML = `<p class="error">Ë©ï‰º∞Á≠îÊ°àÊôÇÂá∫ÈåØÔºåË´ãÈáçË©¶„ÄÇ</p>`;
            submitBtn.disabled = false;
            submitBtn.innerHTML = getTranslation('submitAnswerButton');
        }
    }

    function renderQuizEndScreen() {
        contentArea.innerHTML = `
            <div class="quiz-container">
                <h2>${getTranslation('quizCompleteTitle')}</h2>
                <p class="progress-text">${getTranslation('finalScore')}: ${quizScore} / ${maxQuizScore}</p>
                <button id="restartQuizBtn">${getTranslation('restartQuizButton')}</button>
            </div>`;
        document.getElementById('restartQuizBtn').addEventListener('click', () => {
            quizIndex = 0; quizScore = 0; renderQuizMode();
        });
    }
    
    function renderMatchGame() {
        let gameItems = [];
        flashcards.forEach((card, index) => {
            gameItems.push({ text: card.term, pairId: index, type: 'term' });
            gameItems.push({ text: card.definition, pairId: index, type: 'definition' });
        });
        
        gameItems.sort(() => Math.random() - 0.5); // Shuffle

        const gameContainer = document.createElement('div');
        gameContainer.className = 'match-game-container';
        
        gameItems.forEach(item => {
            const cardEl = document.createElement('div');
            cardEl.className = 'match-card';
            cardEl.dataset.pairId = item.pairId;
            cardEl.innerHTML = `<div class="match-card-content">${item.text}</div>`;
            gameContainer.appendChild(cardEl);
        });
        contentArea.appendChild(gameContainer);

        let flippedCards = [];
        let matchedPairs = 0;
        
        gameContainer.addEventListener('click', (e) => {
            const clickedCard = e.target.closest('.match-card');
            if (!clickedCard || clickedCard.classList.contains('flipped') || flippedCards.length >= 2) {
                return;
            }

            clickedCard.classList.add('flipped');
            flippedCards.push(clickedCard);

            if (flippedCards.length === 2) {
                const [card1, card2] = flippedCards;
                if (card1.dataset.pairId === card2.dataset.pairId) {
                    // Match
                    card1.classList.add('matched');
                    card2.classList.add('matched');
                    flippedCards = [];
                    matchedPairs++;
                    if (matchedPairs === flashcards.length) {
                        setTimeout(renderMatchEndScreen, 600);
                    }
                } else {
                    // Mismatch
                    card1.classList.add('mismatched');
                    card2.classList.add('mismatched');
                    setTimeout(() => {
                        card1.classList.remove('flipped', 'mismatched');
                        card2.classList.remove('flipped', 'mismatched');
                        flippedCards = [];
                    }, 1000);
                }
            }
        });
    }

    function renderMatchEndScreen() {
        contentArea.innerHTML = `
            <div class="quiz-container match-completion-message">
                <h2>${getTranslation('matchGameComplete')}</h2>
                <div style="display: flex; gap: 1rem; margin-top: 1rem;">
                    <button id="playAgainBtn">${getTranslation('playAgainButton')}</button>
                    <button id="returnToStudyBtn" class="button secondary">${getTranslation('returnToStudyButton')}</button>
                </div>
            </div>`;
        document.getElementById('playAgainBtn').addEventListener('click', renderMatchGame);
        document.getElementById('returnToStudyBtn').addEventListener('click', () => handleStudyModeChange('study'));
    }

    // --- Dictation Mode AI Functions ---
    async function translateVocabulary() {
        if (!initializeAi()) { showStatus('errorApiKey', 'error'); return; }
        const list = dictationListInput.value.trim();
        if (!list) { showStatus('errorDictationList', 'error'); return; }

        showStatus('statusTranslating');
        toggleLoading(translateButton, true);
        
        try {
            const prompt = `For the following list of English vocabulary, provide a concise Traditional Chinese translation for each item suitable for HKDSE students. Here is the list:\n\n${list}`;
            const result = await ai.models.generateContent({
                model: 'gemini-2.5-flash', contents: { parts: [{ text: prompt }] }, config: { responseMimeType: "application/json", responseSchema: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: { english: { type: Type.STRING }, chinese: { type: Type.STRING } } } } }
            });
            const translations = JSON.parse(result.text);
            if (translations && translations.length > 0) {
                dictationListInput.value = translations.map(t => `${t.english} - ${t.chinese}`).join('\n');
                showStatus('');
            }
        } catch(error) {
            console.error('Error translating list:', error);
            showStatus(getTranslation('errorGeneral') + (error.message || getTranslation('errorUnknown')), 'error');
        } finally {
            toggleLoading(translateButton, false);
        }
    }

    async function parseVocabularyList() {
        if (!initializeAi()) { return null; }
        const list = dictationListInput.value.trim();
        if (!list) { showStatus('errorDictationList', 'error'); return null; }

        showStatus('statusParsing');
        toggleLoading(startDictationButton, true);
        
        try {
            const prompt = `Analyze the following text which contains a vocabulary list. For each item, identify the primary English term and its corresponding Traditional Chinese translation, if one is provided. Structure the output as a JSON array of objects, where each object has an "english" key and a "chinese" key. If no Chinese translation is found for an item, the value for "chinese" should be an empty string. Text:\n\n${list}`;
            const result = await ai.models.generateContent({
                model: 'gemini-2.5-flash', contents: { parts: [{ text: prompt }] }, config: { responseMimeType: "application/json", responseSchema: { type: Type.ARRAY, items: { type: Type.OBJECT, properties: { english: { type: Type.STRING }, chinese: { type: Type.STRING } } } } }
            });
            const parsedList = JSON.parse(result.text);
            if (parsedList && parsedList.length > 0) {
                return parsedList.filter(item => item.english); // Filter out any empty entries
            }
            return null;
        } catch(error) {
            console.error('Error parsing list:', error);
            showStatus(getTranslation('errorGeneral') + (error.message || getTranslation('errorUnknown')), 'error');
            return null;
        } finally {
            toggleLoading(startDictationButton, false);
            showStatus('');
        }
    }

    // --- Dictation Mode Functions ---
    async function startDictation() {
        if (!('speechSynthesis' in window)) { showStatus('errorSpeechSynthesis', 'error'); return; }
        const parsedWords = await parseVocabularyList();
        if (!parsedWords || parsedWords.length === 0) { showStatus('errorNoValidWords', 'error'); return; }
        
        dictationWords = parsedWords;
        userAnswers = [];
        currentDictationIndex = 0;
        showStatus('');
        showDictationPage(true);
        renderDictationPractice();
    }
    
    function renderDictationPractice() {
        dictationPage.innerHTML = '';
        if (currentDictationIndex >= dictationWords.length) {
            renderDictationResults();
            return;
        }

        const currentItem = dictationWords[currentDictationIndex];
        const content = document.createElement('div');
        content.className = 'dictation-page-content';
        content.innerHTML = `
            <button class="back-button dictation-page-back-button" aria-label="${getTranslation('backButtonLabel')}">‚Üê</button>
            <div class="progress-text">${getTranslation('dictationWord')} ${currentDictationIndex + 1} / ${dictationWords.length}</div>
            ${currentItem.chinese ? `<div class="dictation-translation">${currentItem.chinese}</div>` : ''}
            <button class="dictation-listen-button" aria-label="Listen to the word">üîä</button>
            <input type="text" class="dictation-answer-input" placeholder="${getTranslation('quizAnswerPlaceholder')}" />
            <div id="dictationFeedback" class="dictation-feedback"></div>
            <button id="checkDictationBtn">${getTranslation('checkButton')}</button>`;
        dictationPage.appendChild(content);

        const listenBtn = content.querySelector('.dictation-listen-button');
        const checkBtn = content.querySelector('#checkDictationBtn');
        const answerInput = content.querySelector('.dictation-answer-input');
        const backBtn = content.querySelector('.dictation-page-back-button');
        
        answerInput.focus();
        speakWord(currentItem.english);

        listenBtn.addEventListener('click', () => speakWord(currentItem.english));
        const checkAnswerHandler = () => checkDictationAnswer(answerInput, currentItem, checkBtn);
        checkBtn.addEventListener('click', checkAnswerHandler);
        answerInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') checkAnswerHandler();
        });
        backBtn.addEventListener('click', () => {
          showDictationPage(false);
          showView('dictation');
        });
    }
    
    function speakWord(word) {
        const utterance = new SpeechSynthesisUtterance(word);
        utterance.lang = 'en-US'; // Ensure correct pronunciation
        speechSynthesis.speak(utterance);
    }

    function checkDictationAnswer(inputEl, currentItem, buttonEl) {
        const userAnswer = inputEl.value.trim();
        if (!userAnswer) return;

        const correctWord = currentItem.english;
        const isCorrect = userAnswer.toLowerCase() === correctWord.toLowerCase();
        userAnswers.push({ word: correctWord, userAnswer, isCorrect });
        
        inputEl.disabled = true;
        inputEl.style.borderColor = isCorrect ? 'var(--correct-color)' : 'var(--error-color)';
        
        const feedbackEl = document.getElementById('dictationFeedback');
        if (!isCorrect) {
            feedbackEl.textContent = `${getTranslation('feedbackCorrectAnswerIs')} ${correctWord}`;
            feedbackEl.style.color = 'var(--error-color)';
        } else {
            feedbackEl.textContent = '‚úî';
            feedbackEl.style.color = 'var(--correct-color)';
        }

        buttonEl.textContent = getTranslation('nextWordButton');
        buttonEl.focus();
        buttonEl.onclick = () => {
            currentDictationIndex++;
            renderDictationPractice();
        };
    }
    
    function renderDictationResults() {
        const correctCount = userAnswers.filter(a => a.isCorrect).length;
        const content = document.createElement('div');
        content.className = 'dictation-page-content';

        let tableRows = userAnswers.map(answer => `
            <tr>
                <td data-label="${getTranslation('correctWord')}">${answer.word}</td>
                <td data-label="${getTranslation('yourAnswer')}">
                    <span class="${answer.isCorrect ? '' : 'status-incorrect'}">${answer.userAnswer || '-'}</span>
                    ${!answer.isCorrect ? `<div class="correct-answer-feedback">${getTranslation('feedbackCorrectAnswerIs')} ${answer.word}</div>` : ''}
                </td>
                <td data-label="${getTranslation('status')}" class="${answer.isCorrect ? 'status-correct' : 'status-incorrect'}">${answer.isCorrect ? '‚úî' : '‚úñ'}</td>
            </tr>`).join('');

        content.innerHTML = `
            <h2>${getTranslation('dictationCompleteTitle')}</h2>
            <p class="progress-text">${getTranslation('finalScore')}: ${correctCount} / ${dictationWords.length}</p>
            <div style="max-height: 40vh; overflow-y: auto;">
              <table class="dictation-results-table">
                  <thead><tr><th>${getTranslation('correctWord')}</th><th>${getTranslation('yourAnswer')}</th><th>${getTranslation('status')}</th></tr></thead>
                  <tbody>${tableRows}</tbody>
              </table>
            </div>
            <div style="display: flex; gap: 1rem; margin-top: 1.5rem; justify-content: center;">
                <button id="practiceAgainBtn">${getTranslation('practiceAgainButton')}</button>
                <button id="backToMenuBtn" class="button secondary">${getTranslation('backToMenuButton')}</button>
            </div>`;
        dictationPage.innerHTML = '';
        dictationPage.appendChild(content);
        
        document.getElementById('practiceAgainBtn').addEventListener('click', startDictation);
        document.getElementById('backToMenuBtn').addEventListener('click', () => {
            showDictationPage(false);
            showView('selection');
        });
    }
    
    // --- Start the App ---
    initialize();

  </script>
</body>
</html>